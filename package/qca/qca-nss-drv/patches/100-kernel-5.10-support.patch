diff --git a/Makefile b/Makefile
index c4b4843..40e8808 100644
--- a/Makefile
+++ b/Makefile
@@ -172,7 +172,7 @@ endif
 ccflags-y += -I$(obj)/nss_hal/include -I$(obj)/nss_data_plane/include -I$(obj)/exports -DNSS_DEBUG_LEVEL=0 -DNSS_PKT_STATS_ENABLED=1
 
 ccflags-y += -DNSS_PM_DEBUG_LEVEL=0 -DNSS_SKB_REUSE_SUPPORT=1
-ccflags-y += -Werror
+# ccflags-y += -Werror
 
 ifneq ($(findstring 3.4, $(KERNELVERSION)),)
 NSS_CCFLAGS = -DNSS_DT_SUPPORT=0 -DNSS_FW_DBG_SUPPORT=1 -DNSS_PM_SUPPORT=1
diff --git a/nss_core.c b/nss_core.c
index 8f40063..a8b1538 100644
--- a/nss_core.c
+++ b/nss_core.c
@@ -26,6 +26,7 @@
 #include <nss_hal.h>
 #include <net/dst.h>
 #include <linux/etherdevice.h>
+#include <linux/kmemleak.h>
 #include "nss_tx_rx_common.h"
 #include "nss_data_plane.h"
 
@@ -45,7 +46,9 @@
 (((LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)))) || \
 (((LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 11, 0)))) || \
 (((LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)))) || \
-(((LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))))))
+(((LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0)))) || \
+(((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(5, 5, 0)))) || \
+(((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0))))))
 #error "Check skb recycle code in this file to match Linux version"
 #endif
 
@@ -395,7 +398,11 @@ static void nss_get_ddr_info(struct nss_mmu_ddr_info *mmu, char *name)
 	struct device_node *node;
 
 	si_meminfo(&vals);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0))
+	cached = global_zone_page_state(NR_FILE_PAGES);
+#else
 	cached = global_page_state(NR_FILE_PAGES);
+#endif /*KERNEL_VERSION(4, 14, 0)*/
 	avail_ddr = (vals.totalram + cached + vals.sharedram) * vals.mem_unit;
 	mmu->num_active_cores = nss_top_main.num_nss;
 
@@ -691,7 +698,11 @@ static inline void nss_core_handle_virt_if_pkt(struct nss_ctx_instance *nss_ctx,
 	 * Mimic Linux behavior to allow multi-queue netdev choose which queue to use
 	 */
 	if (ndev->netdev_ops->ndo_select_queue) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		queue_offset = ndev->netdev_ops->ndo_select_queue(ndev, nbuf, NULL);
+#else
 		queue_offset = ndev->netdev_ops->ndo_select_queue(ndev, nbuf, NULL, NULL);
+#endif /*KERNEL_VERSION(5, 3, 0)*/
 	}
 
 	skb_set_queue_mapping(nbuf, queue_offset);
@@ -2322,7 +2333,11 @@ static inline bool nss_skb_can_reuse(struct nss_ctx_instance *nss_ctx,
 	 * This check is added to avoid deadlock from nf_conntrack
 	 * when ecm is trying to flush a rule.
 	 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0))
+	if (unlikely(skb_nfct(nbuf))) {
+#else
 	if (unlikely(nbuf->nfct)) {
+#endif /*KERNEL_VERSION(4, 11, 0)*/
 		return false;
 	}
 #endif
@@ -2332,7 +2347,11 @@ static inline bool nss_skb_can_reuse(struct nss_ctx_instance *nss_ctx,
 	 * This check is added to avoid deadlock from nf_bridge
 	 * when ecm is trying to flush a rule.
 	 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0))
+	if (unlikely(skb_ext_exist(nbuf, SKB_EXT_BRIDGE_NF))) {
+#else
 	if (unlikely(nbuf->nf_bridge)) {
+#endif /*KERNEL_VERSION(4, 11, 0)*/
 		return false;
 	}
 #endif
diff --git a/nss_data_plane/nss_data_plane_gmac.c b/nss_data_plane/nss_data_plane_gmac.c
index 1345cbb..73b681c 100644
--- a/nss_data_plane/nss_data_plane_gmac.c
+++ b/nss_data_plane/nss_data_plane_gmac.c
@@ -20,7 +20,7 @@
 #include "nss_tx_rx_common.h"
 #include <nss_gmac_api_if.h>
 
-#define NSS_DP_GMAC_SUPPORTED_FEATURES (NETIF_F_HIGHDMA | NETIF_F_HW_CSUM | NETIF_F_RXCSUM | NETIF_F_SG | NETIF_F_FRAGLIST | (NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_UFO))
+#define NSS_DP_GMAC_SUPPORTED_FEATURES (NETIF_F_HIGHDMA | NETIF_F_HW_CSUM | NETIF_F_RXCSUM | NETIF_F_SG | NETIF_F_FRAGLIST | (NETIF_F_TSO | NETIF_F_TSO6))
 #define NSS_DATA_PLANE_GMAC_MAX_INTERFACES 4
 
 static DEFINE_SPINLOCK(nss_data_plane_gmac_stats_lock);
diff --git a/nss_hal/fsm9010/nss_hal_pvt.c b/nss_hal/fsm9010/nss_hal_pvt.c
index 360835b..bec05f1 100644
--- a/nss_hal/fsm9010/nss_hal_pvt.c
+++ b/nss_hal/fsm9010/nss_hal_pvt.c
@@ -145,7 +145,7 @@ static struct nss_platform_data *__nss_hal_of_get_pdata(struct platform_device *
 	npd->nphys = res_nphys.start;
 	npd->vphys = res_vphys.start;
 
-	npd->nmap = ioremap_nocache(npd->nphys, resource_size(&res_nphys));
+	npd->nmap = ioremap(npd->nphys, resource_size(&res_nphys));
 	if (!npd->nmap) {
 		nss_info_always("%p: nss%d: ioremap() fail for nphys\n", nss_ctx, nss_ctx->id);
 		goto out;
diff --git a/nss_hal/ipq60xx/nss_hal_pvt.c b/nss_hal/ipq60xx/nss_hal_pvt.c
index a015232..84fd6e4 100644
--- a/nss_hal/ipq60xx/nss_hal_pvt.c
+++ b/nss_hal/ipq60xx/nss_hal_pvt.c
@@ -193,13 +193,13 @@ static struct nss_platform_data *__nss_hal_of_get_pdata(struct platform_device *
 	npd->nphys = res_nphys.start;
 	npd->qgic_phys = res_qgic_phys.start;
 
-	npd->nmap = ioremap_nocache(npd->nphys, resource_size(&res_nphys));
+	npd->nmap = ioremap(npd->nphys, resource_size(&res_nphys));
 	if (!npd->nmap) {
 		nss_info_always("%p: nss%d: ioremap() fail for nphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
-	npd->qgic_map = ioremap_nocache(npd->qgic_phys, resource_size(&res_qgic_phys));
+	npd->qgic_map = ioremap(npd->qgic_phys, resource_size(&res_qgic_phys));
 	if (!npd->qgic_map) {
 		nss_info_always("%p: nss%d: ioremap() fail for qgic map\n", nss_ctx, nss_ctx->id);
 		goto out;
@@ -401,13 +401,13 @@ static int __nss_hal_common_reset(struct platform_device *nss_dev)
 
 	of_node_put(cmn);
 
-	nss_misc_reset = ioremap_nocache(res_nss_misc_reset.start, resource_size(&res_nss_misc_reset));
+	nss_misc_reset = ioremap(res_nss_misc_reset.start, resource_size(&res_nss_misc_reset));
 	if (!nss_misc_reset) {
 		pr_err("%p: ioremap fail for nss_misc_reset\n", nss_dev);
 		return -EFAULT;
 	}
 
-	nss_misc_reset_flag = ioremap_nocache(res_nss_misc_reset_flag.start, resource_size(&res_nss_misc_reset_flag));
+	nss_misc_reset_flag = ioremap(res_nss_misc_reset_flag.start, resource_size(&res_nss_misc_reset_flag));
 	if (!nss_misc_reset_flag) {
 		pr_err("%p: ioremap fail for nss_misc_reset_flag\n", nss_dev);
 		return -EFAULT;
diff --git a/nss_hal/ipq806x/nss_hal_pvt.c b/nss_hal/ipq806x/nss_hal_pvt.c
index 875fc47..8cc8ac9 100644
--- a/nss_hal/ipq806x/nss_hal_pvt.c
+++ b/nss_hal/ipq806x/nss_hal_pvt.c
@@ -458,7 +458,7 @@ static struct nss_platform_data *__nss_hal_of_get_pdata(struct platform_device *
 	npd->nphys = res_nphys.start;
 	npd->vphys = res_vphys.start;
 
-	npd->nmap = ioremap_nocache(npd->nphys, resource_size(&res_nphys));
+	npd->nmap = ioremap(npd->nphys, resource_size(&res_nphys));
 	if (!npd->nmap) {
 		nss_info_always("%p: nss%d: ioremap() fail for nphys\n", nss_ctx, nss_ctx->id);
 		goto out;
@@ -710,7 +710,7 @@ static int __nss_hal_common_reset(struct platform_device *nss_dev)
 	}
 	of_node_put(cmn);
 
-	fpb_base = ioremap_nocache(res_nss_fpb_base.start, resource_size(&res_nss_fpb_base));
+	fpb_base = ioremap(res_nss_fpb_base.start, resource_size(&res_nss_fpb_base));
 	if (!fpb_base) {
 		pr_err("%p: ioremap fail for nss_fpb_base\n", nss_dev);
 		return -EFAULT;
diff --git a/nss_hal/ipq807x/nss_hal_pvt.c b/nss_hal/ipq807x/nss_hal_pvt.c
index 3b09e07..862cc71 100644
--- a/nss_hal/ipq807x/nss_hal_pvt.c
+++ b/nss_hal/ipq807x/nss_hal_pvt.c
@@ -233,7 +233,7 @@ static struct nss_platform_data *__nss_hal_of_get_pdata(struct platform_device *
 	npd->vphys = res_vphys.start;
 	npd->qgic_phys = res_qgic_phys.start;
 
-	npd->nmap = ioremap_nocache(npd->nphys, resource_size(&res_nphys));
+	npd->nmap = ioremap(npd->nphys, resource_size(&res_nphys));
 	if (!npd->nmap) {
 		nss_info_always("%p: nss%d: ioremap() fail for nphys\n", nss_ctx, nss_ctx->id);
 		goto out;
@@ -245,7 +245,7 @@ static struct nss_platform_data *__nss_hal_of_get_pdata(struct platform_device *
 		goto out;
 	}
 
-	npd->qgic_map = ioremap_nocache(npd->qgic_phys, resource_size(&res_qgic_phys));
+	npd->qgic_map = ioremap(npd->qgic_phys, resource_size(&res_qgic_phys));
 	if (!npd->qgic_map) {
 		nss_info_always("%p: nss%d: ioremap() fail for qgic map\n", nss_ctx, nss_ctx->id);
 		goto out;
@@ -463,7 +463,7 @@ static int __nss_hal_common_reset(struct platform_device *nss_dev)
 	}
 	of_node_put(cmn);
 
-	nss_misc_reset = ioremap_nocache(res_nss_misc_reset.start, resource_size(&res_nss_misc_reset));
+	nss_misc_reset = ioremap(res_nss_misc_reset.start, resource_size(&res_nss_misc_reset));
 	if (!nss_misc_reset) {
 		pr_err("%p: ioremap fail for nss_misc_reset\n", nss_dev);
 		return -EFAULT;
diff --git a/nss_hal/nss_hal.c b/nss_hal/nss_hal.c
index c1edd6a..ddd61ee 100644
--- a/nss_hal/nss_hal.c
+++ b/nss_hal/nss_hal.c
@@ -78,9 +78,9 @@ int nss_hal_firmware_load(struct nss_ctx_instance *nss_ctx, struct platform_devi
 		return rc;
 	}
 
-	load_mem = ioremap_nocache(npd->load_addr, nss_fw->size);
+	load_mem = ioremap(npd->load_addr, nss_fw->size);
 	if (!load_mem) {
-		nss_info_always("%p: ioremap_nocache failed: %x", nss_ctx, npd->load_addr);
+		nss_info_always("%p: ioremap failed: %x", nss_ctx, npd->load_addr);
 		release_firmware(nss_fw);
 		return rc;
 	}
diff --git a/nss_meminfo.c b/nss_meminfo.c
index 29bc594..f2fd9af 100644
--- a/nss_meminfo.c
+++ b/nss_meminfo.c
@@ -687,7 +687,7 @@ bool nss_meminfo_init(struct nss_ctx_instance *nss_ctx)
 	/*
 	 * meminfo_start is the label where the start address of meminfo map is stored.
 	 */
-	meminfo_start = (uint32_t *)ioremap_nocache(nss_ctx->load + NSS_MEMINFO_MAP_START_OFFSET,
+	meminfo_start = (uint32_t *)ioremap(nss_ctx->load + NSS_MEMINFO_MAP_START_OFFSET,
 							NSS_MEMINFO_RESERVE_AREA_SIZE);
 	if (!meminfo_start) {
 		nss_info_always("%p: cannot remap meminfo start\n", nss_ctx);
diff --git a/nss_n2h.c b/nss_n2h.c
index 552642a..73da94b 100644
--- a/nss_n2h.c
+++ b/nss_n2h.c
@@ -19,6 +19,7 @@
  *	NSS N2H node APIs
  */
 
+#include <linux/kmemleak.h>
 #include "nss_tx_rx_common.h"
 #include "nss_n2h_stats.h"
 
diff --git a/nss_ppe.c b/nss_ppe.c
index 3dc5679..d6f5e92 100644
--- a/nss_ppe.c
+++ b/nss_ppe.c
@@ -354,7 +354,7 @@ void nss_ppe_init(void)
 	/*
 	 * Get the PPE base address
 	 */
-	ppe_pvt.ppe_base = ioremap_nocache(PPE_BASE_ADDR, PPE_REG_SIZE);
+	ppe_pvt.ppe_base = ioremap(PPE_BASE_ADDR, PPE_REG_SIZE);
 	if (!ppe_pvt.ppe_base) {
 		nss_warning("DRV can't get PPE base address\n");
 		return;
